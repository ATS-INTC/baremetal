use core::{future::poll_fn, task::Poll};

/// This test is only used to check that the AxiNet with `smoltcp` can work normally.

use alloc::{boxed::Box, vec};
use ats_intc::{Task, TaskRef, TaskType};
use smoltcp::socket::tcp::*;
use crate::netstack::*;

pub fn atsintc_test() {
    crate::netstack::init();
    #[cfg(feature = "smp")]
    boot::boot_other(console::hart_id());
    log::info!("poll_test begin");
    // let net_task = Task::new(
    //     Box::pin(net_task()), 
    //     0, 
    //     TaskType::Other, 
    //     &ATSINTC
    // );
    // log::info!("net_task {:?}", net_task);
    // ATSINTC.ps_push(net_task, 0);
    let tcp_task = Task::new(
        Box::pin(server()), 
        0, 
        TaskType::Other, 
        &ATSINTC
    );
    log::info!("tcp_task {:?}", tcp_task);
    ATSINTC.ps_push(tcp_task, 0);
    // ATSINTC.intr_push(2, net_task.clone());
    loop {
        if let Some(task) = ATSINTC.ps_fetch() {
            log::info!("fetch task {:?}", task);
            if task.clone().poll().is_pending() {
                log::debug!("task is pending");
                ATSINTC.intr_push(4, task);
            }
        }
    }
}

const MTU: usize = 1514;

// #[allow(unused)]
// async fn net_task() -> i32 {
//     poll_fn(|cx| {
//         iface_poll();
//         log::info!("poll here");
//         let ptr = cx.waker().as_raw().data() as _;
//         let task = unsafe { TaskRef::virt_task(ptr) };
//         ATSINTC.intr_push(2, task);
//         core::task::Poll::<i32>::Pending
//     }).await
// }

async fn server() -> i32 {
    let tcp_rx_socket = SocketBuffer::new(vec![0u8; MTU * 100]);
    let tcp_tx_socket = SocketBuffer::new(vec![0u8; MTU * 100]);
    let tcp_socket = Socket::new(tcp_rx_socket, tcp_tx_socket);
    let tcp_handle = SOCKET_SET.lock().add(tcp_socket);
    let mut flag = false;
    loop {
        receive().await;
        // iface_poll();
        // poll_fn(|cx| {
        //     // iface_poll();
        //     // log::debug!("poll none");
        //     flag = !flag;
        //     if flag {

        //         cx.waker().wake_by_ref();
        //         Poll::Pending
        //     } else {
        //         Poll::Ready(0)
        //     }
        // }).await;
    }
    // loop {

    //     // let mut socket_set = SOCKET_SET.lock();
    //     // let socket = socket_set.get_mut::<Socket>(tcp_handle);
    //     // if !socket.is_open() {
    //     //     log::info!("socket is not open, listen 80");
    //     //     socket.listen(80).unwrap();
    //     // }
    //     // if socket.can_recv() {
    //     //     if let Ok(_data) = socket.recv(|data| {
    //     //         (data.len(), data)
    //     //     }) {
    //     //         if socket.can_send() {
    //     //             let _ = socket.send(|data| {
    //     //                 data[0..10].copy_from_slice("connect ok".as_bytes());
    //     //                 (data.len(), data)
    //     //             });
    //     //         }
    //     //     }
    //     // }
    //     // drop(socket_set);
    // }
}

#[no_mangle]
pub extern "C" fn rust_main_init_other(_hart_id: usize) {
    // log::info!("secondary hart start");
    // server();
    loop {}
}